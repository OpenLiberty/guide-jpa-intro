// Copyright (c) 2018 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-layout: guide
:projectid: jpa-intro
:page-duration: 20 minutes
:page-releasedate: 2018-07-18
:page-description: Learn how to perform CRUD operations using JPA
:page-tags: ['JPA']
:page-related-guides: ['cdi-intro']
:page-permalink: /guides/{projectid}
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
= Accessing data using Java Persistence API

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, 
view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to map Java Objects to database tables and perform CRUD operations using JPA

:eventapp-url: http://localhost:9080/eventmanager.jsf
:get-events-url: http://localhost:9080/events

== What you'll learn

You will learn how to use the Java Persistence API (JPA) to map Java objects to database tables.
JPA is a standard for Object Relational Mapping and eliminates the burden of having to write
SQL code when performing database operations.

The application that you will be working with is the event manager, which provides services for 
creating, retrieving, updating and deleting event entities. The application uses an Embedded Derby 
database as a datastore for all the events.

You will use JPA annotations to define an entity class whose fields are persisted to the 
database. Every entity object is managed by an `EntityManager` that will be injected into our
Enterprise Java Bean (EJB). In this guide, you will learn how to use a container-managed 
`EntityManager` so you will not need to explicity begin, commit or rollback database transactions,
the EJB container will manage the transaction boundaries for you.

// =================================================================================================
// Getting Started
// =================================================================================================

include::{common-includes}/gitclone.adoc[]

// =================================================================================================
// Try what you'll build
// =================================================================================================

include::{common-includes}/trywhatyoubuild-intro.adoc[]

Point your browser to the {eventapp-url} URL. The event application
currently has no events stored in the database. Go ahead and click on the `Create Event` button 
located in the left navigation bar. After entering an event name, location and time, click on `Submit` 
to persist your event entity to the database. The event is now stored in the database and is visible 
in the list of current events.

Notice that if you stop the Open Liberty server:
```
mvn liberty:stop-server
```

and then restart it:
```
mvn liberty:start-server
```

The events created are still displayed in the list of current events. The `Update` button located 
beside each event allows you to make modifications to the persisted entity and the `Delete` button 
allows you to remove entities from the database.

include::{common-includes}/trywhatyoubuild-end.adoc[]

// =================================================================================================
// Defining a JPA entity class
// =================================================================================================

== Defining a JPA entity class

Navigate to the `start` directory to begin.

To store Java objects in a database, you must define a JPA entity class. A JPA entity is a Java 
object whose non-transient fields will be persisted to the database. Any Plain Old Java Object (POJO) 
class can be designated as a JPA entity. However, the class must be annotated with the `@Entity` 
annotation, must not be declared final and must have a public or protected non-argument constructor. 
JPA uses a database table for every entity and persisted instances will be represented as one row in 
the table.

Add JPA annotations to the `Event` class and all of its fields in the 
`src/main/java/io/openliberty/guides/jpaguide/models/Event.java` file:

[source, Java]
----
include::finish/src/main/java/io/openliberty/guides/jpaguide/models/Event.java[tags=!copyright;]
----

Lets break down the new annotations:

[cols="35, 200", options="header"]
|===
| *Annotation*    | *Description*
| `@Entity` | Declares the class as an entity
| `@Table`  | Specifies details of the table such as name 
| `@NamedQuery` | Specfies a database query using a static name
| `@Id`       |   Primary key of the entity
| `@GeneratedValue`    | Specifies the generation strategy for the value of the primary key, 
                        `strategy = GenerationType.AUTO` indicates that the persistence provider 
                        will pick a strategy depending on the database used
| `@Column`    | Specifies that the field is mapped to a column in the database table, `name` is 
                 optional and indicates the name of the column in the table
|===

// =================================================================================================
// Configuring the `EntityManager`
// =================================================================================================

== Configuring the `EntityManager`

An `EntityManager` instance provides the functionality for performing operations on the database 
such as persisting, loading, updating and deleting entities. The configuration of the `EntityManager`
instance is defined by a persistence unit specified in the `persistence.xml` file.

Create the `src/main/resources/META-INF/persistence.xml` file:

[source, Xml]
----
include::finish/src/main/resources/META-INF/persistence.xml[tags=**;]
----

The persistence unit is defined by the `<persistence-unit name="jpa-unit" transaction-type="JTA"></persistence-unit>` 
XML element. The `name` attribute is required and is used to identify the persistent unit. The 
`transaction-type=”JTA”` element specifies to use Java Transaction API (JTA) transactions. In a Java 
EE environment, the default is JTA if this element is not specified.

The `eclipselink.ddl-generation` properties are used for creating the database tables: 
[source, xml, role="no_copy]
----
<property name="eclipselink.ddl-generation" value="create-tables"/>
<property name="eclipselink.ddl-generation.output-mode" value="both" />
----
They are used here to avoid having to manually create a database table to run this sample application. 
To learn more about the `ddl-generation` properties, see the http://www.eclipse.org/eclipselink/documentation/2.4/jpa/extensions/p_ddl_generation.htm[
Java Persistence API (JPA) Extensions Reference for EclipseLink.]

The `eclipselink.logging.level` properties are used to specify the EclipseLink logging levels 
that are displayed in the WAS server log.

[source, xml, role="no_copy]
----
<property name="eclipselink.logging.level" value="ALL"/>
<property name="eclipselink.logging.level.sql" value="FINE"/>
----
To learn more, see the http://www.eclipse.org/eclipselink/documentation/2.4/jpa/extensions/p_logging_level.htm[
Java Persistence API (JPA) Extensions Reference for EclipseLink.]

A JTA transaction type requires a data source to be provided. This is done through the 
`<jta-data-source>jdbc/samplejpadatasource</jta-data-source>` element which specifies the Java Naming 
and Directory Interface (JNDI) name of the data source that is to be used by the EJB container. 
This means that a Java Database Connectivity (JDBC) connection does not have to be specified in the 
`persistence.xml` file and instead the data source can be preconfigured in the `server.xml`.

Configure the data source in the `src/main/liberty/config/server.xml` file:

[source, Xml]
----
include::finish/src/main/liberty/config/server.xml[tags=**;]
----

The `<library id="derbyJDBCLib"></library>` element is a shared library that points to the directory
of the JDBC driver. The JDBC driver is what enables the application to interact with the database.

The data source configuration is done within the `<dataSource id="samplejpadatasource jndiName="jdbc/samplejpadatasource"></dataSource>`
element. The `<properties.derby.embedded databaseName="JPAGuide" createDatabase="create"/>` attribute
within the data source configuration contains embedded derby properties such as the database name 
and whether to create the database if it does not already exist.

// =================================================================================================
// Performing CRUD operations using JPA
// =================================================================================================

== Performing CRUD operations using JPA

CRUD is an abbreviation that defines the four basic functionalities that can be performed on a 
database: create, read, update and delete.

Create the `src/main/java/io/openliberty/guides/jpaguide/dao/EventDao.java` file:

[source, Java]
----
include::finish/src/main/java/io/openliberty/guides/jpaguide/dao/EventDao.java[tags=!copyright;]
----

In order to use the `EntityManager` at runtime, it must be injected into our EJB component through the
`@PersistenceContext` annotation. Since the `EntityManager` is container-managed, the EJB container
will ensure that the methods are executed within an active transaction which is why it is not necessary
to explicitly begin, commit or rollback transactions. At the end of an EJB oeration, the persistence 
context will be notified that the transaction is committing and the persistence provider, EclipseLink,
will flush the changes to the database.

The `EventDao.java` class has a method for each CRUD operation, so let's break them down:

* The `createEvent()` method persists an instance of the `Event` entity class to the datastore by
calling the `persist()` method on an `EntityManager` instance. The argument passed into the `persist()`
method must be an instance of an entity class, otherwise an `IllegalArgumentException` will be thrown.  

* The `readEvent()` method will return an instance of the `Event` entity class with the specified 
primary key by calling the `find()` method on an `EntityManager` instance. The find method accepts
both the entity class and the primary key as arguments. If the `Event` instance is not found, `Null` 
will be returned.

* The `updateEvent()` method updates an instance of the `Event` entity class in the database. The 
`EntityManager` automatically tracks entity objects in the persistence context for changes and synchronizes
them with the database. The `merge()` method will copy the entity supplied as an argument into a new 
`Event` instance that will be added to the persistence context so that its changes can be tracked.

* The `deleteEvent()` method removes an instance of the `Event` entity class from the database by 
calling the `remove()` method on an `EntityManager` instance. An instance of an entity class must
be passed as an argument to the `remove()` method, otherwise an `IllegalArgumentException` will be
thrown.

// =================================================================================================
// Building and running the application
// =================================================================================================

include::{common-includes}/mvnbuild.adoc[]

When the server is running, visit the {eventapp-url} URL to view the Event Manager application. 

Using the `Create event` button in the left navigation bar you are able to create events that will 
be persisted to the database. Once you have created an event, it will be available to view, update 
and delete in the `Event list` section.

// Use the following include to pull in the Liberty start/stop server instructions from the
// guides-common repo.
include::{common-includes}/mvncompile.adoc[]

// Instructions to rebuild the application

// =================================================================================================
// Testing the application
// =================================================================================================

== Testing the application

Create the `EventAppTest` test class in the `finish/src/test/java/it/io/openliberty/guides/jpaguide/tests/EventAppTest.java` 
file:

[source, Java]
----
include::finish/src/test/java/it/io/openliberty/guides/jpaguide/tests/EventAppTest.java[tags=!copyright;]
----

The `testCreatingDeletingNewEvent` method creates a test `Event` object and persists it to the database. 
All the `Event` objects are then retrieved from the database to verify that the test event was actually 
persisted. Next, the test event is removed from the database and all `Event` objects are retrieved 
to verify the test event is no longer stored. 

The `testUpdatingEvents` method also creates a test event and verifies that it is stored in the database.
Next, the test event's name, location and time is updated. All `Event` objects are retrieved from the 
database to verify that the updated event is stored. Finally, the updated test event is deleted and 
one final check is done to ensure the updated test event is no longer stored in the database.

// Include this for info on how to run the tests
include::{common-includes}/mvnverify.adoc[]

[source, role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.jpaguide.tests.EventAppTest
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.9 sec - in it.io.openliberty.guides.jpaguide.tests.EventAppTest

Results :

Tests run: 2, Failures: 0, Errors: 0, Skipped: 0
----

// =================================================================================================
// Great work! You're done!
// =================================================================================================

== Great work! You're done!

You have learned how to map Java objects to database tables by defining a JPA entity class whose 
instances are represented as rows in the table.

You have have learned how to configure an `EntityManager` and use container-managed transactions
to perform basic CRUD operations on a database using JPA. 

include::{common-includes}/finish.adoc[]
